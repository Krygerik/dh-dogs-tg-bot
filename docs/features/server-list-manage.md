# Server List: Manage (страница управления секцией)

## Цель
В секции **Server List** для каждой активной секции добавить кнопку **Manage**,
которая открывает отдельную страницу управления выбранной секцией.

Страница должна показывать всю необходимую пользователю информацию по выбранной
секции, **исключая**:
- `custom modifiers`
- `mods`

Дополнительно (план): страница Manage должна показывать максимально возможную
информацию о внутриигровом окружении и о каждом игроке через Frida‑инструментацию,
без заметного ухудшения производительности сервера.

## UX / Поведение
- Кнопка **Manage** отображается **только** для секций со статусом `active`/`running`.
- Нажатие **Manage** открывает новую страницу (не модалку).
- На странице слева сверху есть кнопка **Назад**:
  - основной сценарий: `history.back()`;
  - fallback: переход в `Server List`, если history недоступен.

## Идентификатор секции
Для навигации и получения данных используется `port`.

Пример route (клиентский):
- `/sessions/:port`

> Конкретный путь — ответственность клиента; для API используется параметр `port`.

## Данные / Контракт API (Вариант B)
Для страницы Manage используется отдельный эндпоинт (не `/status`).

### `GET /session?port=<port>`
Возвращает подробную информацию по одной сессии/секции.

**Query**
- `port` — номер порта (обязателен)

**Response 200**
```json
{
  "ok": true,
  "session": {
    "mapName": "Departure",
    "mapValue": "Departure_P",
    "port": 7777,
    "pid": 4242,
    "ip": "185.17.66.195",
    "startedAt": "2026-02-09T10:20:30.000Z"
  }
}
```

**Ошибки**
- `400` — если `port` не задан или некорректен
  ```json
  { "ok": false, "error": "port is required" }
  ```
- `404` — если сессия по порту не найдена (завершилась/не существует)
  ```json
  { "ok": false, "error": "Session not found" }
  ```

### Важно: что НЕ должно попасть на страницу
Страница **не показывает** и эндпоинт `GET /session` **не должен возвращать**:
- `mods`
- `customModifiers`

### Telemetry API (proxy)
Если телеметрия включена, API может проксировать локальный bridge:

- `GET /telemetry?port=<port>`
  - возвращает последний snapshot из локального telemetry bridge
  - ошибки: `404`, если телеметрия не включена для сессии

- `POST /telemetry/command`
  - тело: `{ "port": 7777, "command": { ... } }`
  - проксирует команду в telemetry bridge `/command`

## Frida‑телеметрия (план)
Цель телеметрии — давать оператору максимально подробную картину игры в real‑time:

### Список желаемых данных
- время игры (таймер / стадия / фаза)
- настройки мира
- игрок (per-player):
  - здоровье
  - холод
  - голод
  - имя
  - роль
  - статус предателя
  - количество маны
  - инвентарь
  - координаты
  - статус: жив / мёртв / упал / спит / в тюрьме

### Принципиальная архитектура (без нагрузки на сервер)
- **Внутри процесса игры (Frida JS)**: только сбор данных из памяти/хуки + формирование
  компактных "снимков" или "дельт".
- **Вне процесса игры (Python loader / bridge)**: сеть (HTTP/WS/pipe), сериализация,
  хранение последнего состояния, backpressure.

Рекомендуемый транспорт для UI:
- **WebSocket на `127.0.0.1`** (push, удобно для live‑панели)
- Альтернатива: **Named Pipe** (Windows, минимальный overhead)
- HTTP pull (как fallback): UI периодически запрашивает последний snapshot

### Формат сообщений (рекомендуемо)
- Сервер телеметрии держит в памяти `latestState` и отправляет:
  - `state` (полный snapshot) при первом подключении
  - `delta` (только изменения) далее

Пример (сокращённо):
```json
{
  "t": 1739123456789,
  "type": "delta",
  "match": { "time": 512, "phase": "in_game" },
  "players": {
    "changed": {
      "p_123": {
        "name": "Player",
        "role": "Cook",
        "traitor": false,
        "hp": 85,
        "cold": 12,
        "hunger": 40,
        "mana": 50,
        "pos": [123.4, 55.1, 9.0],
        "status": "alive"
      }
    }
  }
}
```

## Реалистичный план внедрения (по этапам)
Ниже — план, ориентированный на "максимум данных" при минимальном риске регрессий.
Критичный принцип: **все тяжёлые операции и сеть — вне процесса игры**.

### Этап 0 — База для Manage (API + UI без телеметрии)
**Цель**: подготовить страницу Manage и отдельный эндпоинт на бэке, чтобы было куда
подключать телеметрию.

**Действия**
- **Бэк (`src/api-server.ts`)**
  - добавить `GET /session?port=`:
    - ищет активную сессию по `port`;
    - возвращает `{ mapName, mapValue, port, pid, ip, startedAt }`;
    - НЕ возвращает `mods` и `customModifiers`.
- **Клиент**
  - добавить кнопку **Manage** (только `active/running`) и роут `/sessions/:port`;
  - на странице Manage: загрузка `GET /session?port=...`, кнопка **Назад**.

**Риски/заметки**
- `port` может переиспользоваться — поэтому на Manage показывать `pid` + `startedAt`
  (как "якорь", что это текущая сессия).

### Этап 1 — "Транспорт" телеметрии (bridge) без UE‑данных
**Цель**: поднять стабильный канал доставки данных до UI с минимальным вмешательством
в игру.

**Действия**
- **Python (`frida/loader.py`)**
  - добавить режим "telemetry bridge":
    - поднять локальный сервер (предпочтительно WebSocket) на `127.0.0.1:<port>`;
    - принимать сообщения из Frida (`on_message`) и публиковать в WS клиентам;
    - хранить `latestState` для новых подключений.
  - добавить ограничители:
    - лимит частоты отправки (rate limit);
    - лимит размера сообщений;
    - backpressure: если клиентов нет/они не успевают — сбрасывать обновления,
      сохраняя только `latestState`.
- **Frida JS (новый скрипт)**
  - создать "пустую" телеметрию, которая раз в N мс отправляет heartbeat:
    - `type: state`, `pid`, `serverTime`, `mapValue`, `port` (если доступно).

**Где в проекте**
- Новый скрипт: `patches/stable/telemetry/telemetry.js` (или отдельная папка под фичу)
- Описание: `patches/stable/telemetry/telemetry.txt` (кратко)
- Bridge: правки в `frida/loader.py`

**Критерии готовности**
- UI может подключиться по WS/pipe и получить стабильный поток сообщений (пусть пока
  без игровых полей).

### Этап 2 — Игровое время + список игроков (минимальный полезный набор)
**Цель**: дать оператору основу: таймер/фаза и список игроков, обновляемые без лагов.

**Действия**
- **Frida JS (`telemetry.js`)**
  - найти "якорные" UE‑точки (предпочтение более живучим методам):
    - `GWorld`/World → `GameState`/`GameMode` (таймер/фаза);
    - `PlayerState` список (имя, роль/команда, признаки alive/dead если есть).
  - отправлять:
    - `match.time`, `match.phase`
    - `players[]`: `playerId`, `name`, `status` (alive/dead/spectator)
  - частота:
    - матч/игровое время: 1–2 Гц
    - список игроков: 1–2 Гц (или по событию подключения/отключения)
- **Python bridge**
  - агрегировать state+delta (чтобы UI не утонул в объёме).

**Производительность**
- не сканировать объекты каждый тик; найти указатели один раз и кэшировать;
- если "якорь" потерян — перескан с ограничением (например раз в 5–10 сек).

### Этап 3 — Per-player параметры (HP/Cold/Hunger/Mana/Pos/Status)
**Цель**: добавить ключевые параметры "по каждому игроку".

**Действия**
- **Frida JS**
  - для каждого игрока получить ссылки на Pawn/Character и компоненты статов;
  - собрать поля:
    - `hp`, `cold`, `hunger`, `mana`
    - `pos` (координаты) + опционально `vel`
    - `status`: alive/dead/downed/sleeping/jailed (по флагам/enum)
  - отправка:
    - "лёгкие метрики" (`pos`, `hp`) 5–10 Гц (если реально нужно live);
    - "тяжёлые/редкие" (`role`, `traitor`, jail/sleep) 1–2 Гц или по событию.

**Производительность**
- диффить значения: если не поменялось — не отправлять;
- лимитировать игроков/поля, если включён режим "low perf".

### Этап 4 — Инвентарь + настройки мира
**Цель**: расширить наблюдаемость до инвентаря и параметров мира.

**Действия**
- **Frida JS**
  - инвентарь: извлечь список предметов/слотов (ID/кол-во/состояние);
  - настройки мира: найти структуру правил/настроек (GameMode/GameState/Config)
    и сериализовать в компактный вид.
- **Python bridge**
  - хранить "большие" поля отдельными сообщениями/каналами, чтобы не засорять
    основной realtime‑поток (например `type: inventory`, `type: worldSettings`).

**Производительность**
- инвентарь и world settings обновлять редко (0.2–1 Гц) или по событиям.

### Этап 5 — Полировка: стабильность, совместимость, профилирование
**Цель**: сделать систему устойчивой к обновлениям игры и удобной в эксплуатации.

**Действия**
- **Версионировать протокол** (`protocolVersion`) и добавлять `buildInfo`.
- **Фича‑флаги**: включать/выключать группы данных (pos/hp/inventory).
- **Самодиагностика**:
  - время цикла сбора;
  - размер сообщений;
  - dropped updates;
  - причины рескана/потери якорей.
- **Fail‑safe**: при ошибках чтения памяти — деградировать (выключать часть полей),
  но не валить серверный процесс.

### Этап 6 — Operator Control (write): изменение мира/сессии/игроков
**Цель**: добавить оператору управляемые действия (из UI) с минимальным риском крашей,
читов и деградации производительности. По умолчанию система остаётся в режиме
`read-only`.

#### Требуемые операторские действия
- устанавливать внутриигровое **время суток**
- менять **предустановленные настройки сессии**
- менять параметры/статус/предателя/предметы **конкретного игрока**

#### Реалистичность и ограничения (важно)
- **Время суток**: чаще всего возможно "на лету", но зависит от того, где это хранится
  (WorldSettings/GameState/GameMode) и не перезаписывается ли игрой/скриптами.
- **Предустановки сессии**: в большинстве игр это **надежнее применять на старте
  сессии**, а не в середине матча. Поэтому реалистичный вариант:
  - менять "preset" для **следующего запуска**, или
  - применять сейчас через **контролируемый рестарт сессии** (если допустимо).
- **Изменение игрока** (статы/статус/предатель/инвентарь): возможно, но безопаснее
  делать через "правильные" внутриигровые функции/команды, чем прямой записью
  в поля памяти. Запись в память — fallback и будет ломаться при обновлениях.

#### Протокол команд (пример)
Команды идут **Operator UI → Bridge → Frida**, ответ возвращается `ack`/`error`.

- `commandId`: UUID/монотонный id для корреляции
- `port/pid`: привязка к конкретной активной сессии
- `op`: имя операции из allowlist
- `params`: строго типизированные параметры

Примеры:
```json
{
  "type": "command",
  "commandId": "c9c8c5b0-4b6a-4b86-9b5e-1f2c2b5c6e00",
  "port": 7777,
  "op": "set_time_of_day",
  "params": { "time": 13.5 }
}
```

```json
{
  "type": "command",
  "commandId": "8c3b8d6e-7b7a-4ab8-9d6a-3d3d1d6f1a11",
  "port": 7777,
  "op": "apply_session_preset",
  "params": { "presetId": "hardcore_v2", "mode": "next_session" }
}
```

```json
{
  "type": "command",
  "commandId": "b1f7a7a1-2d84-4e2a-9d3a-2a6c3a3a3a3a",
  "port": 7777,
  "op": "set_player_state",
  "params": {
    "playerId": "p_123",
    "hp": 100,
    "cold": 0,
    "hunger": 0,
    "mana": 50,
    "traitor": false,
    "status": "alive"
  }
}
```

```json
{
  "type": "command",
  "commandId": "f0f0f0f0-0000-0000-0000-000000000001",
  "port": 7777,
  "op": "inventory_give_item",
  "params": { "playerId": "p_123", "itemId": "coal", "amount": 3 }
}
```

Ответ:
```json
{ "type": "ack", "commandId": "...", "ok": true }
```
или
```json
{ "type": "ack", "commandId": "...", "ok": false, "error": "Player not found" }
```

#### Где реализуется (что и где менять)
- **Operator UI**
  - в Manage‑странице добавить "Control" (отдельная вкладка/секция), скрытую по
    умолчанию (read-only), с явным переключателем "Enable control".
- **Bridge (Python `frida/loader.py`)**
  - принимать команды от UI (WS/HTTP/pipe)
  - валидировать по allowlist + схемам + диапазонам
  - rate limit (например N команд/сек)
  - аудит (логировать команды и результаты)
  - пересылать в Frida (`script.post(...)` / message channel)
- **Frida JS (`telemetry.js` или отдельный `control.js`)**
  - обработчик входящих команд
  - выполнение операции **только** из allowlist
  - предпочтение: вызывать "штатные" функции/команды игры
  - fallback: запись в память (только для простых, хорошо изученных полей)

#### Предустановки сессии (presets): точные поля и хранение
Presets предназначены для **стандартизированных наборов настроек**, которые оператор
может:
- применить к **следующей** сессии (`mode: next_session`), или
- применить к текущей через **контролируемый рестарт** (`mode: restart_session`).

Рекомендуемое хранение в `tg-bot`:
- `reference/session_presets.json` — источник правды (структура ниже)
- `reference/session_presets.ru.json` — локализация `name`/`description` (опционально)

Схема `reference/session_presets.json`:
```json
{
  "presets": [
    {
      "id": "hardcore_v2",
      "name": "Hardcore v2",
      "description": "Меньше ресурсов, больше угроз.",
      "applyMode": ["next_session", "restart_session"],
      "sessionParamsOverride": "daysbeforeblizzard=2?maxplayers=8?thralls=3",
      "world": {
        "timeOfDay": 13.5
      },
      "playerDefaults": {
        "hp": 100,
        "cold": 0,
        "hunger": 0,
        "mana": 0
      },
      "limits": {
        "maxInventoryGiveAmount": 5
      }
    }
  ]
}
```

Описание полей:
- `id` (string, required): стабильный идентификатор preset'а (используется в `apply_session_preset`).
- `name` (string, required): отображаемое имя (может быть переопределено локализацией).
- `description` (string, optional): краткое описание для UI.
- `applyMode` (array, required): допустимые режимы применения: `next_session`, `restart_session`.
- `sessionParamsOverride` (string, optional): строка параметров, аналогичная `SESSION_PARAMS`.
  Используется при старте следующей сессии (или при рестарте).
- `world` (object, optional): параметры мира (минимум `timeOfDay` если поддерживается).
  Другие поля добавляются только после подтверждения, что игра их хранит/читает на сервере.
- `playerDefaults` (object, optional): значения по умолчанию для "мягких" операций над игроком.
  Это **не** означает автоприменение ко всем игрокам — только удобные дефолты в UI.
- `limits` (object, optional): ограничения для write‑операций, чтобы не ломать баланс/сервер.

Важно:
- Preset'ы **не должны** включать `mods` и `custom modifiers` как часть Manage UI.
  Если когда‑то потребуется — это отдельная фича/экран, отдельные политики доступа.

#### "Безопасные" vs "опасные" команды (политика по умолчанию)
Классификация нужна, чтобы включать write‑контур без риска для стабильности:

**Безопасные (разрешены по умолчанию при включенном control)**
- `set_time_of_day`:
  - ограничения: `time` в диапазоне `0..24`, rate limit (например 1/сек)
  - причина: изменение одного параметра мира, легко валидировать
- `apply_session_preset` с `mode: next_session`:
  - причина: не трогает текущий матч, только меняет конфиг следующего запуска
- "мягкие" изменения игрока (при строгих лимитах и allowlist полей):
  - `set_player_state` (только: `hp`, `cold`, `hunger`, `mana`, `status` в безопасных enum)
  - ограничения: диапазоны, rate limit, запрет массового применения
- "простые" операции с инвентарём (если есть штатный путь через внутриигровые функции):
  - `inventory_give_item` / `inventory_remove_item`
  - ограничения: allowlist `itemId`, лимит количества, запрет спама

**Опасные (только high‑risk режим + отдельное подтверждение)**
- `set_player_traitor` / принудительное изменение "предателя"
  - причина: влияет на core‑логику матча, может требовать серверных проверок/репликации
- `teleport_player` / forced position set
  - причина: может ломать физику/античит/репликацию, часто приводит к десинкам
- `spawn_actor` / создание предметов/объектов "в мире" произвольных типов
  - причина: риск утечек, крашей, нагрузка, неочевидные зависимости UE
- `exec_console_command` / произвольные команды
  - причина: огромная поверхность атаки/ошибок, не должно существовать в allowlist

**Рекомендованная политика**
- по умолчанию включается только safe‑подмножество;
- опасные операции требуют:
  - отдельного флага окружения (например `TELEMETRY_CONTROL_RISK=high`);
  - дополнительного подтверждения в UI;
  - полного аудита команд и ограничителей.

#### Безопасность (обязательные требования)
- отдельный токен/секрет для write‑команд (не смешивать с read API)
- allowlist операций (никаких произвольных eval/адресов)
- диапазоны значений (например `time: 0..24`, `hp: 0..max`)
- запрет опасных операций в high‑risk режимах (например spawn больших объектов)
- "panic switch": мгновенно выключить control без рестарта процесса

## UI состояния
- **Loading**: до получения ответа API.
- **Not found (404)**: "Сессия завершена или не найдена" + кнопка "Назад".
- **Error**: сообщение об ошибке + кнопка Retry + кнопка "Назад".

## Ограничения и замечания
- `port` может переиспользоваться после остановки сессии. Поэтому deep-link
  на `/sessions/:port` может открыть уже "другую" сессию (если она запущена на том
  же порту). Клиенту рекомендуется явно показывать `startedAt` и `pid`, чтобы
  пользователь видел, что это именно текущая активная сессия.
